{% extends 'modern-layout.html' %}
{% block breadcrumbs %}Data Log Management{% endblock breadcrumbs %}

{% block content %}
<!-- Page Header -->
<div class="row mb-4">
    <div class="col-12">
        <div class="modern-card">
            <div class="modern-card-header">
                <h3 class="modern-card-title">
                    <i class="fas fa-exclamation-triangle text-warning me-2"></i>
                    Data Log Management
                </h3>
            </div>
            <div class="modern-card-body">
                <p class="text-muted mb-0">Monitor and manage data in Redis and SQLite.</p>
            </div>
        </div>
    </div>
</div>

<!-- Storage Overview -->
<div class="row mb-4">
    <div class="col-12">
        <div class="modern-card">
            <div class="modern-card-header">
                <h5 class="modern-card-title">
                    <i class="fas fa-chart-bar text-info me-2"></i>
                    Storage Overview
                </h5>
            </div>
            <div class="modern-card-body">
                <div class="row g-4">
                    <div class="col-lg-4 col-md-6">
                        <div class="stats-card">
                            <div class="stats-card-header">
                                <h6 class="stats-card-title">Redis Storage</h6>
                                <div class="stats-card-icon bg-danger">
                                    <i class="fas fa-memory"></i>
                                </div>
                            </div>
                            <h3 class="stats-card-value" id="redis-storage">Loading...</h3>
                            <p class="stats-card-subtitle">Memory Usage</p>
                        </div>
                    </div>
                    <div class="col-lg-4 col-md-6">
                        <div class="stats-card">
                            <div class="stats-card-header">
                                <h6 class="stats-card-title">SQLite Storage</h6>
                                <div class="stats-card-icon bg-warning">
                                    <i class="fas fa-hdd"></i>
                                </div>
                            </div>
                            <h3 class="stats-card-value" id="sqlite-storage">Loading...</h3>
                            <p class="stats-card-subtitle">Disk Usage</p>
                        </div>
                    </div>
                    <div class="col-lg-4 col-md-6">
                        <div class="stats-card">
                            <div class="stats-card-header">
                                <h6 class="stats-card-title">Disk Usage</h6>
                                <div class="stats-card-icon bg-success">
                                    <i class="fas fa-hdd"></i>
                                </div>
                            </div>
                            <h3 class="stats-card-value">
                                <span class="stats-card-value" id="disk-usage">Loading...</span>
                            </h3>
                            <p class="stats-card-subtitle">Storage Space</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Data Statistics -->
<div class="row mb-4">
    <div class="col-12">
        <div class="modern-card">
            <div class="modern-card-header">
                <h5 class="modern-card-title">
                    <i class="fas fa-chart-line text-success me-2"></i>
                    Data Statistics
                </h5>
            </div>
            <div class="modern-card-body">
                <div class="row g-4">
                    <div class="col-lg-4 col-md-6">
                        <div class="stats-card">
                            <div class="stats-card-header">
                                <h6 class="stats-card-title">Logger Records</h6>
                                <div class="stats-card-icon bg-primary">
                                    <i class="fas fa-list-ol"></i>
                                </div>
                            </div>
                            <h3 class="stats-card-value" id="datalog-length">Loading...</h3>
                            <p class="stats-card-subtitle">Logger Data Records</p>
                        </div>
                    </div>
                    <div class="col-lg-4 col-md-6">
                        <div class="stats-card">
                            <div class="stats-card-header">
                                <h6 class="stats-card-title">SQLite Records</h6>
                                <div class="stats-card-icon bg-warning">
                                    <i class="fas fa-database"></i>
                                </div>
                            </div>
                            <h3 class="stats-card-value" id="sqlite-length">Loading...</h3>
                            <p class="stats-card-subtitle">Database Records</p>
                        </div>
                    </div>
                    <div class="col-lg-4 col-md-6">
                        <div class="stats-card">
                            <div class="stats-card-header">
                                <h6 class="stats-card-title">Last Update</h6>
                                <div class="stats-card-icon bg-info">
                                    <i class="fas fa-clock"></i>
                                </div>
                            </div>
                            <h3 class="stats-card-value" id="last-update">Loading...</h3>
                            <p class="stats-card-subtitle">Data Refresh</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Data Operations -->
<div class="row">
    <div class="col-12">
        <div class="modern-card">
            <div class="modern-card-header">
                <h3 class="modern-card-title">
                    <i class="fas fa-tools"></i>
                    Data Operations
                </h3>
            </div>
            <div class="modern-card-body">
                <div class="row g-3">
                    <div class="col-lg-3 col-md-6">
                        <div class="modern-card">
                            <div class="modern-card-body text-center">
                                <div class="mb-3">
                                    <i class="fas fa-download text-primary" style="font-size: 2rem;"></i>
                                </div>
                                <h5 class="mb-3">Download Logger Data</h5>
                                <p class="text-muted mb-3">Export all Data logs to JSON files</p>
                                <button class="btn btn-modern btn-primary w-100" id="download-datalog" onclick="downloadLoggers();">
                                    <i class="fas fa-download"></i>
                                    Download Data Logs
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-3 col-md-6">
                        <div class="modern-card">
                            <div class="modern-card-body text-center">
                                <div class="mb-3">
                                    <i class="fas fa-download text-warning" style="font-size: 2rem;"></i>
                                </div>
                                <h5 class="mb-3">Download SQLite Data</h5>
                                <p class="text-muted mb-3">Export SQLite database to JSON</p>
                                <button class="btn btn-modern btn-warning w-100" id="download-sqlite" onclick="downloadSqliteData();">
                                    <i class="fas fa-download"></i>
                                    Download SQLite
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-3 col-md-6">
                        <div class="modern-card">
                            <div class="modern-card-body text-center">
                                <div class="mb-3">
                                    <i class="fas fa-trash-alt text-danger" style="font-size: 2rem;"></i>
                                </div>
                                <h5 class="mb-3">Clear Redis Data</h5>
                                <p class="text-muted mb-3">Remove all Redis cache data</p>
                                <button class="btn btn-modern btn-danger w-100" id="clear-redis" onclick="clearRedisData();">
                                    <i class="fas fa-trash-alt"></i>
                                    Clear Redis
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-3 col-md-6">
                        <div class="modern-card">
                            <div class="modern-card-body text-center">
                                <div class="mb-3">
                                    <i class="fas fa-trash-alt text-danger" style="font-size: 2rem;"></i>
                                </div>
                                <h5 class="mb-3">Clear SQLite Data</h5>
                                <p class="text-muted mb-3">Remove all SQLite database data</p>
                                <button class="btn btn-modern btn-danger w-100" id="clear-sqlite" onclick="clearSqliteData();">
                                    <i class="fas fa-trash-alt"></i>
                                    Clear SQLite
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Upload Data Operations -->
<div class="row mt-4">
    <div class="col-12">
        <div class="modern-card">
            <div class="modern-card-header">
                <h3 class="modern-card-title">
                    <i class="fas fa-upload text-success me-2"></i>
                    Upload Data Operations
                </h3>
            </div>
            <div class="modern-card-body">
                <div class="row g-4">
                    <!-- Upload SQLite Data by Date Range -->
                    <div class="col-lg-6">
                        <div class="modern-card border-success">
                            <div class="modern-card-header">
                                <h5 class="modern-card-title">
                                    <i class="fas fa-database text-success me-2"></i>
                                    Upload SQLite Data by Date Range
                                </h5>
                            </div>
                            <div class="modern-card-body">
                                <form id="upload-sqlite-form">
                                    <div class="row">
                                        <div class="col-md-6">
                                            <div class="mb-3">
                                                <label for="sqlite-start-date" class="form-label">
                                                    <i class="fas fa-calendar-alt me-2"></i>
                                                    Start Date
                                                </label>
                                                <input type="date" class="form-control" id="sqlite-start-date" required>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <div class="mb-3">
                                                <label for="sqlite-end-date" class="form-label">
                                                    <i class="fas fa-calendar-alt me-2"></i>
                                                    End Date
                                                </label>
                                                <input type="date" class="form-control" id="sqlite-end-date" required>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="mb-3">
                                        <label for="sqlite-table-name" class="form-label">
                                            <i class="fas fa-table me-2"></i>
                                            Table Name (Optional)
                                        </label>
                                        <input type="text" class="form-control" id="sqlite-table-name" placeholder="Leave empty for all tables">
                                    </div>
                                    <div class="mb-3">
                                        <label for="sqlite-batch-size" class="form-label">
                                            <i class="fas fa-layer-group me-2"></i>
                                            Batch Size
                                        </label>
                                        <select class="form-control" id="sqlite-batch-size">
                                            <option value="100">100 records</option>
                                            <option value="500" selected>500 records</option>
                                            <option value="1000">1000 records</option>
                                            <option value="2000">2000 records</option>
                                        </select>
                                    </div>
                                    <div class="alert alert-info" role="alert">
                                        <i class="fas fa-info-circle me-2"></i>
                                        <small>This will upload SQLite data from the specified date range to the remote server.</small>
                                    </div>
                                    <div class="d-grid">
                                        <button type="button" class="btn btn-modern btn-success" id="upload-sqlite-btn" onclick="uploadSqliteDataByRange();">
                                            <i class="fas fa-upload me-2"></i>
                                            Upload SQLite Data
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    </div>

                    <!-- Upload Redis Data by Date Range -->
                    <div class="col-lg-6">
                        <div class="modern-card border-info">
                            <div class="modern-card-header">
                                <h5 class="modern-card-title">
                                    <i class="fas fa-memory text-info me-2"></i>
                                    Upload Redis Data by Date Range
                                </h5>
                            </div>
                            <div class="modern-card-body">
                                <form id="upload-redis-form">
                                    <div class="row">
                                        <div class="col-md-6">
                                            <div class="mb-3">
                                                <label for="redis-start-date" class="form-label">
                                                    <i class="fas fa-calendar-alt me-2"></i>
                                                    Start Date
                                                </label>
                                                <input type="date" class="form-control" id="redis-start-date" required>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <div class="mb-3">
                                                <label for="redis-end-date" class="form-label">
                                                    <i class="fas fa-calendar-alt me-2"></i>
                                                    End Date
                                                </label>
                                                <input type="date" class="form-control" id="redis-end-date" required>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="mb-3">
                                        <label for="redis-key-pattern" class="form-label">
                                            <i class="fas fa-key me-2"></i>
                                            Key Pattern (Optional)
                                        </label>
                                        <input type="text" class="form-control" id="redis-key-pattern" placeholder="e.g., loggers:*, sensor:*">
                                    </div>
                                    <div class="mb-3">
                                        <label for="redis-batch-size" class="form-label">
                                            <i class="fas fa-layer-group me-2"></i>
                                            Batch Size
                                        </label>
                                        <select class="form-control" id="redis-batch-size">
                                            <option value="100">100 records</option>
                                            <option value="500" selected>500 records</option>
                                            <option value="1000">1000 records</option>
                                            <option value="2000">2000 records</option>
                                        </select>
                                    </div>
                                    <div class="alert alert-info" role="alert">
                                        <i class="fas fa-info-circle me-2"></i>
                                        <small>This will upload Redis cache data from the specified date range to the remote server.</small>
                                    </div>
                                    <div class="d-grid">
                                        <button type="button" class="btn btn-modern btn-info" id="upload-redis-btn" onclick="uploadRedisDataByRange();">
                                            <i class="fas fa-upload me-2"></i>
                                            Upload Redis Data
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Upload Progress Modal -->
<div class="modal fade" id="uploadProgressModal" tabindex="-1" aria-labelledby="uploadProgressModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-success text-white">
                <h5 class="modal-title" id="uploadProgressModalLabel">
                    <i class="fas fa-upload me-2"></i>
                    Upload Progress
                </h5>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span id="upload-status-text">Preparing upload...</span>
                        <span id="upload-percentage">0%</span>
                    </div>
                    <div class="progress" style="height: 20px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated bg-success" 
                             id="upload-progress-bar" role="progressbar" style="width: 0%" 
                             aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                        </div>
                    </div>
                </div>
                <div class="row text-center">
                    <div class="col-4">
                        <small class="text-muted">Records Processed</small>
                        <div class="h5" id="upload-processed">0</div>
                    </div>
                    <div class="col-4">
                        <small class="text-muted">Total Records</small>
                        <div class="h5" id="upload-total">0</div>
                    </div>
                    <div class="col-4">
                        <small class="text-muted">Upload Speed</small>
                        <div class="h5" id="upload-speed">0/s</div>
                    </div>
                </div>
                <div class="mt-3">
                    <div class="alert alert-info" role="alert" id="upload-info">
                        <i class="fas fa-info-circle me-2"></i>
                        <span id="upload-info-text">Upload will begin shortly...</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" id="cancel-upload-btn" onclick="cancelUpload();">
                    <i class="fas fa-times me-2"></i>
                    Cancel Upload
                </button>
            </div>
        </div>
    </div>
</div>

{% endblock content %}

{% block scripts %}
<script>
    const siteName = "{{ site_name }}";
    
    // Helper function to update status indicators
    function updateStatusIndicator(elementId, status, activeStates = ['active', 'online', 'healthy'], dangerStates = ['error', 'offline', 'unhealthy']) {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = status;
            
            const statusLower = status.toLowerCase();
            if (activeStates.some(state => statusLower.includes(state))) {
                element.className = 'status-indicator active';
            } else if (dangerStates.some(state => statusLower.includes(state))) {
                element.className = 'status-indicator danger';
            } else {
                element.className = 'status-indicator inactive';
            }
        }
    }

    // Helper function to format file size
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Helper function to update last update time
    function updateLastUpdate() {
        const lastUpdateElement = document.getElementById('last-update');
        if (lastUpdateElement) {
            const now = new Date().toLocaleTimeString();
            lastUpdateElement.textContent = now;
        }
    }

    // Helper function to show loading state
    function showLoadingState() {
        const downloadBtn = document.getElementById('download-datalog');
        const clearBtn = document.getElementById('clear-datalog');
        const refreshBtn = document.getElementById('refresh-datalog');
        
        if (downloadBtn) {
            downloadBtn.disabled = true;
            downloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
        }
        if (clearBtn) {
            clearBtn.disabled = true;
        }
        if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
        }
    }

    // Helper function to reset button states
    function resetButtonStates() {
        const downloadBtn = document.getElementById('download-datalog');
        const clearBtn = document.getElementById('clear-datalog');
        const refreshBtn = document.getElementById('refresh-datalog');
        
        if (downloadBtn) {
            downloadBtn.disabled = false;
            downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download';
        }
        if (clearBtn) {
            clearBtn.disabled = false;
        }
        if (refreshBtn) {
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh';
        }
    }

    // Helper function to disable buttons when no data
    function disableButtonsNoData() {
        const downloadBtn = document.getElementById('download-datalog');
        const clearBtn = document.getElementById('clear-datalog');
        
        if (downloadBtn) {
            downloadBtn.disabled = true;
            downloadBtn.innerHTML = '<i class="fas fa-download"></i> No Data';
        }
        if (clearBtn) {
            clearBtn.disabled = true;
            clearBtn.innerHTML = '<i class="fas fa-trash-alt"></i> No Data';
        }
    }

    const arrLoggersData = [];
    const arrRedisData = [];
    const arrSqliteData = [];
    
    // Function to get Redis data length
    const getRedisDataLength = async () => {
        try {
            const response = await fetch('/api/redis/keys', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            return data.length || 0;
        } catch (error) {
            console.error('Failed to get Redis data length:', error);
            return 0;
        }
    };
    
    // Function to get SQLite data length
    const getSqliteDataLength = async () => {
        try {
            const response = await fetch('/api/sqlite/count', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            return data.count || 0;
        } catch (error) {
            console.error('Failed to get SQLite data length:', error);
            return 0;
        }
    };
    
    // Function to get Redis storage usage
    const getRedisStorage = async () => {
        try {
            const response = await fetch('/api/redis/info', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            return data.used_memory || 0;
        } catch (error) {
            console.error('Failed to get Redis storage:', error);
            return 0;
        }
    };
    
    // Function to get SQLite storage usage
    const getSqliteStorage = async () => {
        try {
            const response = await fetch('/api/sqlite/size', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            return data.size || 0;
        } catch (error) {
            console.error('Failed to get SQLite storage:', error);
            return 0;
        }
    };
    
    // Function to update all data lengths
    const updateAllDataLengths = async () => {
        try {
            const [redisLength, sqliteLength, redisStorage, sqliteStorage] = await Promise.all([
                getRedisDataLength(),
                getSqliteDataLength(),
                getRedisStorage(),
                getSqliteStorage()
            ]);
            
            // Update Redis data
            const redisLengthElement = document.getElementById('redis-length');
            if (redisLengthElement) {
                redisLengthElement.textContent = redisLength.toLocaleString();
            }
            
            // Update SQLite data
            const sqliteLengthElement = document.getElementById('sqlite-length');
            if (sqliteLengthElement) {
                sqliteLengthElement.textContent = sqliteLength.toLocaleString();
            }
            
            // Update Redis storage
            const redisStorageElement = document.getElementById('redis-storage');
            if (redisStorageElement) {
                redisStorageElement.textContent = formatFileSize(redisStorage);
            }
            
            // Update SQLite storage
            const sqliteStorageElement = document.getElementById('sqlite-storage');
            if (sqliteStorageElement) {
                sqliteStorageElement.textContent = formatFileSize(sqliteStorage);
            }
            
            // Update total storage
            const totalStorageElement = document.getElementById('total-storage');
            if (totalStorageElement) {
                const apiStorage = arrLoggersData.length * 1024; // Rough estimate
                const totalStorage = apiStorage + redisStorage + sqliteStorage;
                totalStorageElement.textContent = formatFileSize(totalStorage);
            }
            
        } catch (error) {
            console.error('Failed to update data lengths:', error);
        }
    };
    const handleLoggers = async (cursorValue = "") => {
        showLoadingState();
        
        try {
            const response = await fetch(`/api/loggers/data?cursor=${cursorValue}&page_size=500`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (data.code == 500) {
                console.log(`Error: ${data.status}`);
                updateStatusIndicator('datalog-status', 'Error');
                return;
            }

            // Process the data here
            arrLoggersData.push(...Object.values(data.data));

            // Check if there is a next cursor
            if (data.next_cursor) {
                // If there is a next cursor, make another request with the new cursor value
                handleLoggers(data.next_cursor);
            } else {
                // If next cursor is null, stop the requests
                console.log('No more data to fetch.');
                console.log(`Total data collected: ${arrLoggersData.length}`);
                
                const datalogLengthElement = document.getElementById('datalog-length');
                const storageUsageElement = document.getElementById('storage-usage');
                
                if (datalogLengthElement) {
                    datalogLengthElement.textContent = arrLoggersData.length.toLocaleString();
                    
                    // Update status based on data length
                    if (arrLoggersData.length > 1000) {
                        datalogLengthElement.classList.add('text-warning');
                        updateStatusIndicator('datalog-status', 'High Volume');
                    } else if (arrLoggersData.length > 500) {
                        datalogLengthElement.classList.add('text-info');
                        updateStatusIndicator('datalog-status', 'Normal');
                    } else {
                        updateStatusIndicator('datalog-status', 'Low Volume');
                    }
                }
                
                // Estimate storage usage
                if (storageUsageElement) {
                    const estimatedSize = arrLoggersData.length * 1024; // Rough estimate
                    storageUsageElement.textContent = formatFileSize(estimatedSize);
                }
                
                // Update data health
                updateStatusIndicator('data-health', 'Healthy');
                
                // Update last update time
                updateLastUpdate();
                
                // Update all data lengths (Redis, SQLite)
                updateAllDataLengths();
                
                // Reset button states
                resetButtonStates();
            }
        } catch (error) {
            console.error(`Failed to fetch data: ${error.message}`);
            
            // Update UI for error state
            updateStatusIndicator('datalog-status', 'Error');
            updateStatusIndicator('data-health', 'Error');
            
            // if status is 404, return No Data
            if (error.message.includes('404')) {
                const datalogLengthElement = document.getElementById('datalog-length');
                const storageUsageElement = document.getElementById('storage-usage');
                
                if (datalogLengthElement) {
                    datalogLengthElement.textContent = 'No Data';
                    datalogLengthElement.classList.add('text-muted');
                }
                
                if (storageUsageElement) {
                    storageUsageElement.textContent = '0 Bytes';
                    storageUsageElement.classList.add('text-muted');
                }
                
                updateStatusIndicator('datalog-status', 'No Data');
                updateStatusIndicator('data-health', 'No Data');
                
                disableButtonsNoData();
            } else {
                resetButtonStates();
            }
        }
    };

    // Refresh all data function
    function refreshAllData() {
        arrLoggersData.length = 0; // Clear existing data
        arrRedisData.length = 0;
        arrSqliteData.length = 0;
        handleLoggers();
        updateAllDataLengths();
    }
    
    // Refresh data function (backward compatibility)
    function refreshData() {
        refreshAllData();
    }
    
    // Download Redis data
    const downloadRedisData = async () => {
        const downloadBtn = document.getElementById('download-redis');
        if (downloadBtn) {
            downloadBtn.disabled = true;
            downloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Downloading...';
        }
        
        try {
            const response = await fetch('/api/redis/export', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Create download
            const jsonData = JSON.stringify(data, null, 2);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `${siteName}-redis-export-${timestamp}.json`;
            
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            // Show success message
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('Redis data downloaded successfully!', 'success');
            } else {
                alert('Redis data downloaded successfully!');
            }
            
        } catch (error) {
            console.error('Failed to download Redis data:', error);
            
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('Failed to download Redis data. Please try again.', 'error');
            } else {
                alert('Failed to download Redis data. Please try again.');
            }
        } finally {
            // Reset button
            if (downloadBtn) {
                downloadBtn.disabled = false;
                downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download Redis';
            }
        }
    };
    
    // Download SQLite data
    const downloadSqliteData = async () => {
        const downloadBtn = document.getElementById('download-sqlite');
        if (downloadBtn) {
            downloadBtn.disabled = true;
            downloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Downloading...';
        }
        
        try {
            const response = await fetch('/api/sqlite/export', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Create download
            const jsonData = JSON.stringify(data, null, 2);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `${siteName}-sqlite-export-${timestamp}.json`;
            
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            // Show success message
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('SQLite data downloaded successfully!', 'success');
            } else {
                alert('SQLite data downloaded successfully!');
            }
            
        } catch (error) {
            console.error('Failed to download SQLite data:', error);
            
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('Failed to download SQLite data. Please try again.', 'error');
            } else {
                alert('Failed to download SQLite data. Please try again.');
            }
        } finally {
            // Reset button
            if (downloadBtn) {
                downloadBtn.disabled = false;
                downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download SQLite';
            }
        }
    };
    
    // Clear Redis data
    const clearRedisData = async () => {
        const confirmClear = confirm('⚠️ WARNING: This will permanently delete all Redis cache data!\n\nThis action cannot be undone. Are you sure you want to continue?');
        if (!confirmClear) {
            return;
        }
        
        const clearBtn = document.getElementById('clear-redis');
        if (clearBtn) {
            clearBtn.disabled = true;
            clearBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Clearing...';
        }
        
        try {
            const response = await fetch('/api/redis/clear', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Show success message
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('Redis data cleared successfully!', 'success');
            } else {
                alert('Redis data cleared successfully!');
            }
            
            // Update UI
            const redisLengthElement = document.getElementById('redis-length');
            const redisStorageElement = document.getElementById('redis-storage');
            
            if (redisLengthElement) {
                redisLengthElement.textContent = '0';
            }
            
            if (redisStorageElement) {
                redisStorageElement.textContent = '0 Bytes';
            }
            
            // Update total storage
            updateAllDataLengths();
            
        } catch (error) {
            console.error('Failed to clear Redis data:', error);
            
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('Failed to clear Redis data. Please try again.', 'error');
            } else {
                alert('Failed to clear Redis data. Please try again.');
            }
        } finally {
            // Reset button
            if (clearBtn) {
                clearBtn.disabled = false;
                clearBtn.innerHTML = '<i class="fas fa-trash-alt"></i> Clear Redis';
            }
        }
    };
    
    // Clear SQLite data
    const clearSqliteData = async () => {
        const confirmClear = confirm('⚠️ WARNING: This will permanently delete all SQLite database data!\n\nThis action cannot be undone. Are you sure you want to continue?');
        if (!confirmClear) {
            return;
        }
        
        const clearBtn = document.getElementById('clear-sqlite');
        if (clearBtn) {
            clearBtn.disabled = true;
            clearBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Clearing...';
        }
        
        try {
            const response = await fetch('/api/sqlite/clear', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Show success message
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('SQLite data cleared successfully!', 'success');
            } else {
                alert('SQLite data cleared successfully!');
            }
            
            // Update UI
            const sqliteLengthElement = document.getElementById('sqlite-length');
            const sqliteStorageElement = document.getElementById('sqlite-storage');
            
            if (sqliteLengthElement) {
                sqliteLengthElement.textContent = '0';
            }
            
            if (sqliteStorageElement) {
                sqliteStorageElement.textContent = '0 Bytes';
            }
            
            // Update total storage
            updateAllDataLengths();
            
        } catch (error) {
            console.error('Failed to clear SQLite data:', error);
            
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('Failed to clear SQLite data. Please try again.', 'error');
            } else {
                alert('Failed to clear SQLite data. Please try again.');
            }
        } finally {
            // Reset button
            if (clearBtn) {
                clearBtn.disabled = false;
                clearBtn.innerHTML = '<i class="fas fa-trash-alt"></i> Clear SQLite';
            }
        }
    };
    
    // Download data
    const downloadLoggers = async (cursorValue = "") => {
        const downloadBtn = document.getElementById('download-datalog');
        if (downloadBtn) {
            downloadBtn.disabled = true;
            downloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Downloading...';
        }
        
        try {
            const response = await fetch(`/api/loggers/data?cursor=${cursorValue}&page_size=500`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (data.code == 500) {
                console.log(`Error: ${data.status}`);
                return;
            }

            // Process the data here
            const chunkData = JSON.stringify(data.data, null, 2);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `${siteName}-datalog-${timestamp}-${cursorValue || 'first'}.json`;
            
            const blob = new Blob([chunkData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;

            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);

            // Check if there is a next cursor
            if (data.next_cursor) {
                // If there is a next cursor, make another request with the new cursor value
                downloadLoggers(data.next_cursor);
            } else {
                // If next cursor is null, stop the requests
                console.log('Download complete.');
                
                // Show success message
                if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                    window.powerDeskApp.showNotification('Download completed successfully!', 'success');
                } else {
                    alert('Download completed successfully!');
                }
                
                // Reset button
                if (downloadBtn) {
                    downloadBtn.disabled = false;
                    downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download';
                }
            }
        } catch (error) {
            console.error(`Failed to download data: ${error.message}`);
            
            // Show error message
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('Download failed. Please try again.', 'error');
            } else {
                alert('Download failed. Please try again.');
            }
            
            // Reset button
            if (downloadBtn) {
                downloadBtn.disabled = false;
                downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download';
            }
        }
    };

    // Clear data
    const arrClearLoggers = [];
    const clearLoggers = async (cursorValue) => {
        console.log('Clearing data...');
        
        // Enhanced confirmation dialog
        const confirmClear = confirm('⚠️ WARNING: This will permanently delete all data logs!\n\nThis action cannot be undone. Are you sure you want to continue?');
        if (!confirmClear) {
            return;
        }
        
        const clearBtn = document.getElementById('clear-datalog');
        if (clearBtn) {
            clearBtn.disabled = true;
            clearBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Clearing...';
        }
        
        try {
            const response = await fetch(`/api/loggers/data?cursor=${cursorValue}&page_size=500`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (data.code == 500) {
                console.log(`Error: ${data.status}`);
                return;
            }

            // Process the data here
            // get keys of the data object and push them to the array
            arrClearLoggers.push(...Object.keys(data.data));

            // Check if there is a next cursor
            if (data.next_cursor) {
                // If there is a next cursor, make another request with the new cursor value
                clearLoggers(data.next_cursor);
            } else {
                // If next cursor is null, stop the requests
                // Start deleting the data
                const deletePromises = arrClearLoggers.map((el) => {
                    return fetch(`/api/loggers/data/${el}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer d1587d98aa2348b600edc7e7569e3997'
                        }
                    }).then((response) => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        return response.json();
                    }).then((data) => {
                        console.log(`Data deleted: ${data.status}`);
                        return { status: true };
                    }).catch((error) => {
                        console.error(`Failed to delete data: ${error.message}`);
                        return { status: false };
                    });
                });

                Promise.all(deletePromises).then((results) => {
                    const successResults = results.filter((el) => el.status === true);
                    const errorResults = results.filter((el) => el.status === false);

                    if (successResults.length > 0 && errorResults.length > 0) {
                        if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                            window.powerDeskApp.showNotification('Some data failed to delete. Please try again.', 'warning');
                        } else {
                            alert('Some data failed to delete. Please try again.');
                        }
                    } else if (successResults.length > 0 && errorResults.length === 0) {
                        if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                            window.powerDeskApp.showNotification('All data successfully cleared!', 'success');
                        } else {
                            alert('All data successfully cleared!');
                        }
                        
                        // Update UI
                        const datalogLengthElement = document.getElementById('datalog-length');
                        const storageUsageElement = document.getElementById('storage-usage');
                        
                        if (datalogLengthElement) {
                            datalogLengthElement.textContent = 'No Data';
                            datalogLengthElement.classList.add('text-muted');
                        }
                        
                        if (storageUsageElement) {
                            storageUsageElement.textContent = '0 Bytes';
                            storageUsageElement.classList.add('text-muted');
                        }
                        
                        updateStatusIndicator('datalog-status', 'No Data');
                        updateStatusIndicator('data-health', 'No Data');
                        
                        disableButtonsNoData();
                    }
                }).catch((error) => {
                    console.error(`Failed to delete some data: ${error.message}`);
                    
                    if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                        window.powerDeskApp.showNotification('Failed to delete data. Please try again.', 'error');
                    } else {
                        alert('Failed to delete data. Please try again.');
                    }
                });
            }
        } catch (error) {
            console.error(`Failed to fetch data: ${error.message}`);
            
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('Failed to clear data. Please try again.', 'error');
            } else {
                alert('Failed to clear data. Please try again.');
            }
            
            // Reset button
            if (clearBtn) {
                clearBtn.disabled = false;
                clearBtn.innerHTML = '<i class="fas fa-trash-alt"></i> Clear All';
            }
        }
    };

    // Upload SQLite Data by Date Range
    let uploadCancelled = false;
    let uploadStartTime = null;
    
    const uploadSqliteDataByRange = async () => {
        const startDate = document.getElementById('sqlite-start-date').value;
        const endDate = document.getElementById('sqlite-end-date').value;
        const tableName = document.getElementById('sqlite-table-name').value;
        const batchSize = parseInt(document.getElementById('sqlite-batch-size').value);
        
        if (!startDate || !endDate) {
            alert('Please select both start and end dates.');
            return;
        }
        
        if (new Date(startDate) > new Date(endDate)) {
            alert('Start date cannot be later than end date.');
            return;
        }
        
        // Show progress modal
        showUploadProgress('SQLite');
        uploadCancelled = false;
        uploadStartTime = Date.now();
        
        const uploadBtn = document.getElementById('upload-sqlite-btn');
        if (uploadBtn) {
            uploadBtn.disabled = true;
            uploadBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Uploading...';
        }
        
        try {
            // First, get the count of records in the date range
            const countResponse = await fetch('/api/sqlite/count-by-range', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                },
                body: JSON.stringify({
                    start_date: startDate,
                    end_date: endDate,
                    table_name: tableName
                })
            });
            
            if (!countResponse.ok) {
                throw new Error(`HTTP error! status: ${countResponse.status}`);
            }
            
            const countData = await countResponse.json();
            const totalRecords = countData.count || 0;
            
            if (totalRecords === 0) {
                hideUploadProgress();
                alert('No records found in the specified date range.');
                return;
            }
            
            updateUploadProgress(0, totalRecords, 'Fetching data from SQLite...');
            
            let offset = 0;
            let processedRecords = 0;
            let uploadSuccess = 0;
            let uploadErrors = 0;
            
            while (offset < totalRecords && !uploadCancelled) {
                // Fetch batch of data
                const fetchResponse = await fetch('/api/sqlite/data-by-range', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                    },
                    body: JSON.stringify({
                        start_date: startDate,
                        end_date: endDate,
                        table_name: tableName,
                        limit: batchSize,
                        offset: offset
                    })
                });
                
                if (!fetchResponse.ok) {
                    throw new Error(`HTTP error! status: ${fetchResponse.status}`);
                }
                
                const batchData = await fetchResponse.json();
                
                if (batchData.data && batchData.data.length > 0) {
                    // Upload batch to remote server
                    updateUploadProgress(processedRecords, totalRecords, `Uploading batch ${Math.floor(offset/batchSize) + 1}...`);
                    
                    const uploadResponse = await fetch('/api/upload/sqlite-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                        },
                        body: JSON.stringify({
                            data: batchData.data,
                            batch_info: {
                                start_date: startDate,
                                end_date: endDate,
                                table_name: tableName,
                                batch_number: Math.floor(offset/batchSize) + 1,
                                total_batches: Math.ceil(totalRecords/batchSize)
                            }
                        })
                    });
                    
                    if (uploadResponse.ok) {
                        uploadSuccess += batchData.data.length;
                    } else {
                        uploadErrors += batchData.data.length;
                        console.error(`Failed to upload batch ${Math.floor(offset/batchSize) + 1}`);
                    }
                    
                    processedRecords += batchData.data.length;
                    updateUploadProgress(processedRecords, totalRecords, `Uploaded ${processedRecords} of ${totalRecords} records`);
                }
                
                offset += batchSize;
                
                // Small delay to prevent overwhelming the server
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            hideUploadProgress();
            
            if (uploadCancelled) {
                if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                    window.powerDeskApp.showNotification('Upload cancelled by user.', 'warning');
                } else {
                    alert('Upload cancelled by user.');
                }
            } else {
                const message = `Upload completed! Success: ${uploadSuccess}, Errors: ${uploadErrors}`;
                if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                    window.powerDeskApp.showNotification(message, uploadErrors > 0 ? 'warning' : 'success');
                } else {
                    alert(message);
                }
            }
            
        } catch (error) {
            console.error('Failed to upload SQLite data:', error);
            hideUploadProgress();
            
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('Failed to upload SQLite data. Please try again.', 'error');
            } else {
                alert('Failed to upload SQLite data. Please try again.');
            }
        } finally {
            // Reset button
            if (uploadBtn) {
                uploadBtn.disabled = false;
                uploadBtn.innerHTML = '<i class="fas fa-upload me-2"></i>Upload SQLite Data';
            }
        }
    };
    
    // Upload Redis Data by Date Range
    const uploadRedisDataByRange = async () => {
        const startDate = document.getElementById('redis-start-date').value;
        const endDate = document.getElementById('redis-end-date').value;
        const keyPattern = document.getElementById('redis-key-pattern').value;
        const batchSize = parseInt(document.getElementById('redis-batch-size').value);
        
        if (!startDate || !endDate) {
            alert('Please select both start and end dates.');
            return;
        }
        
        if (new Date(startDate) > new Date(endDate)) {
            alert('Start date cannot be later than end date.');
            return;
        }
        
        // Show progress modal
        showUploadProgress('Redis');
        uploadCancelled = false;
        uploadStartTime = Date.now();
        
        const uploadBtn = document.getElementById('upload-redis-btn');
        if (uploadBtn) {
            uploadBtn.disabled = true;
            uploadBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Uploading...';
        }
        
        try {
            // First, get the keys matching the pattern and date range
            const keysResponse = await fetch('/api/redis/keys-by-range', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                },
                body: JSON.stringify({
                    start_date: startDate,
                    end_date: endDate,
                    key_pattern: keyPattern
                })
            });
            
            if (!keysResponse.ok) {
                throw new Error(`HTTP error! status: ${keysResponse.status}`);
            }
            
            const keysData = await keysResponse.json();
            const keys = keysData.keys || [];
            
            if (keys.length === 0) {
                hideUploadProgress();
                alert('No Redis keys found in the specified date range.');
                return;
            }
            
            updateUploadProgress(0, keys.length, 'Fetching data from Redis...');
            
            let processedKeys = 0;
            let uploadSuccess = 0;
            let uploadErrors = 0;
            
            // Process keys in batches
            for (let i = 0; i < keys.length && !uploadCancelled; i += batchSize) {
                const batchKeys = keys.slice(i, i + batchSize);
                
                // Fetch batch of data from Redis
                const fetchResponse = await fetch('/api/redis/data-by-keys', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                    },
                    body: JSON.stringify({
                        keys: batchKeys
                    })
                });
                
                if (!fetchResponse.ok) {
                    throw new Error(`HTTP error! status: ${fetchResponse.status}`);
                }
                
                const batchData = await fetchResponse.json();
                
                if (batchData.data) {
                    // Upload batch to remote server
                    updateUploadProgress(processedKeys, keys.length, `Uploading batch ${Math.floor(i/batchSize) + 1}...`);
                    
                    const uploadResponse = await fetch('/api/upload/redis-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer d1587d98aa2348b600edc7e7569e3997`
                        },
                        body: JSON.stringify({
                            data: batchData.data,
                            batch_info: {
                                start_date: startDate,
                                end_date: endDate,
                                key_pattern: keyPattern,
                                batch_number: Math.floor(i/batchSize) + 1,
                                total_batches: Math.ceil(keys.length/batchSize)
                            }
                        })
                    });
                    
                    if (uploadResponse.ok) {
                        uploadSuccess += batchKeys.length;
                    } else {
                        uploadErrors += batchKeys.length;
                        console.error(`Failed to upload batch ${Math.floor(i/batchSize) + 1}`);
                    }
                }
                
                processedKeys += batchKeys.length;
                updateUploadProgress(processedKeys, keys.length, `Uploaded ${processedKeys} of ${keys.length} keys`);
                
                // Small delay to prevent overwhelming the server
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            hideUploadProgress();
            
            if (uploadCancelled) {
                if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                    window.powerDeskApp.showNotification('Upload cancelled by user.', 'warning');
                } else {
                    alert('Upload cancelled by user.');
                }
            } else {
                const message = `Upload completed! Success: ${uploadSuccess}, Errors: ${uploadErrors}`;
                if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                    window.powerDeskApp.showNotification(message, uploadErrors > 0 ? 'warning' : 'success');
                } else {
                    alert(message);
                }
            }
            
        } catch (error) {
            console.error('Failed to upload Redis data:', error);
            hideUploadProgress();
            
            if (window.powerDeskApp && window.powerDeskApp.showNotification) {
                window.powerDeskApp.showNotification('Failed to upload Redis data. Please try again.', 'error');
            } else {
                alert('Failed to upload Redis data. Please try again.');
            }
        } finally {
            // Reset button
            if (uploadBtn) {
                uploadBtn.disabled = false;
                uploadBtn.innerHTML = '<i class="fas fa-upload me-2"></i>Upload Redis Data';
            }
        }
    };
    
    // Show upload progress modal
    function showUploadProgress(dataType) {
        const modal = document.getElementById('uploadProgressModal');
        const title = document.getElementById('uploadProgressModalLabel');
        
        title.innerHTML = `<i class="fas fa-upload me-2"></i>Upload ${dataType} Data Progress`;
        
        const progressModal = new bootstrap.Modal(modal);
        progressModal.show();
    }
    
    // Update upload progress
    function updateUploadProgress(processed, total, statusText) {
        const progressBar = document.getElementById('upload-progress-bar');
        const percentage = total > 0 ? Math.round((processed / total) * 100) : 0;
        const statusElement = document.getElementById('upload-status-text');
        const percentageElement = document.getElementById('upload-percentage');
        const processedElement = document.getElementById('upload-processed');
        const totalElement = document.getElementById('upload-total');
        const speedElement = document.getElementById('upload-speed');
        const infoElement = document.getElementById('upload-info-text');
        
        progressBar.style.width = percentage + '%';
        progressBar.setAttribute('aria-valuenow', percentage);
        
        if (statusElement) statusElement.textContent = statusText;
        if (percentageElement) percentageElement.textContent = percentage + '%';
        if (processedElement) processedElement.textContent = processed.toLocaleString();
        if (totalElement) totalElement.textContent = total.toLocaleString();
        
        // Calculate upload speed
        if (uploadStartTime && processed > 0) {
            const elapsed = (Date.now() - uploadStartTime) / 1000; // seconds
            const speed = Math.round(processed / elapsed);
            if (speedElement) speedElement.textContent = speed + '/s';
        }
        
        // Update info text
        if (infoElement) {
            if (percentage === 100) {
                infoElement.textContent = 'Upload completed successfully!';
            } else if (percentage > 75) {
                infoElement.textContent = 'Almost done, finishing upload...';
            } else if (percentage > 50) {
                infoElement.textContent = 'Upload in progress, please wait...';
            } else {
                infoElement.textContent = 'Processing data, this may take a while...';
            }
        }
    }
    
    // Hide upload progress modal
    function hideUploadProgress() {
        const modal = bootstrap.Modal.getInstance(document.getElementById('uploadProgressModal'));
        if (modal) {
            modal.hide();
        }
    }
    
    // Cancel upload
    function cancelUpload() {
        uploadCancelled = true;
        const cancelBtn = document.getElementById('cancel-upload-btn');
        if (cancelBtn) {
            cancelBtn.disabled = true;
            cancelBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Cancelling...';
        }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        handleLoggers();
        updateAllDataLengths();
        
        // Set default date ranges (last 7 days)
        const today = new Date();
        const lastWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
        
        const formatDate = (date) => {
            return date.toISOString().split('T')[0];
        };
        
        // Set default dates for SQLite upload
        document.getElementById('sqlite-start-date').value = formatDate(lastWeek);
        document.getElementById('sqlite-end-date').value = formatDate(today);
        
        // Set default dates for Redis upload
        document.getElementById('redis-start-date').value = formatDate(lastWeek);
        document.getElementById('redis-end-date').value = formatDate(today);
        
        // Update last update time every minute
        setInterval(updateLastUpdate, 60000);
        
        // Update data lengths every 5 minutes
        setInterval(updateAllDataLengths, 300000);
        
        // Form validation for upload forms
        const uploadForms = document.querySelectorAll('#upload-sqlite-form, #upload-redis-form');
        uploadForms.forEach(form => {
            const inputs = form.querySelectorAll('input[type="date"]');
            inputs.forEach(input => {
                input.addEventListener('change', function() {
                    validateDateRange(form);
                });
            });
        });
    });
    
    // Validate date range
    function validateDateRange(form) {
        const startDateInput = form.querySelector('input[type="date"]:first-of-type');
        const endDateInput = form.querySelector('input[type="date"]:last-of-type');
        
        if (startDateInput && endDateInput) {
            const startDate = new Date(startDateInput.value);
            const endDate = new Date(endDateInput.value);
            
            if (startDate > endDate) {
                endDateInput.setCustomValidity('End date must be after start date');
                endDateInput.classList.add('is-invalid');
            } else {
                endDateInput.setCustomValidity('');
                endDateInput.classList.remove('is-invalid');
            }
        }
    }
</script>
{% endblock scripts %}